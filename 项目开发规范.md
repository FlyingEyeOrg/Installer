# C++ 风格指南 (C++ 标准库风格)

## 1. 文件命名

### 1.1 头文件 (.h/.hpp)
```cpp
// 全小写，单词间用下划线分隔
class_name.h
my_utility_functions.h
network_manager.hpp
```

### 1.2 源文件 (.cpp/.cc)
```cpp
// 与头文件同名
class_name.cpp
my_utility_functions.cc
main.cc
```

### 1.3 内联文件 (.inc/.inl)
```cpp
// 内联定义文件
vector_operations.inc
template_implementations.inl
```

## 2. 目录命名

### 2.1 目录结构
```
project_name/           // 全小写，用下划线分隔
├── include/           // 公共头文件
│   └── project_name/  // 项目命名空间目录
├── src/              // 源文件
├── test/             // 测试文件
├── docs/             // 文档
├── third_party/      // 第三方依赖
└── build/           // 构建目录
```

## 3. 命名约定

### 3.1 通用原则
- 名称应具有描述性
- 避免缩写，除非是通用缩写
- 保持一致性

### 3.2 具体规范

#### 3.2.1 类、结构体、类型别名、枚举
```cpp
// 小写下划线命名法 (snake_case)
class url_table { ... };
class url_table_tester { ... };
struct url_table_properties { ... };
using properties_map = std::map<std::string, std::string>;

// 枚举类型
enum class url_table_error { ... };

// 模板类型参数
template <typename T>
class hash_table { ... };

template <typename Key, typename Value>
class map { ... };
```

#### 3.2.2 变量
```cpp
// 普通变量：全小写，下划线分隔
std::string table_name;  // 标准库风格
int url_array_size;      // 标准库风格

// 类数据成员：不添加额外前缀/后缀
class table_info {
 private:
  std::string table_name;  // 标准库风格 - 无特殊标记
  static pool<table_info>* pool;  // 静态成员同样
};

// 结构体成员：普通变量命名
struct url_table_properties {
  std::string name;
  int num_entries;
};
```

#### 3.2.3 常量
```cpp
// 命名空间作用域或类作用域的常量
// 标准库不规定特殊前缀，可全大写
const int days_in_week = 7;
const std::string company_name = "Company";

// 全大写风格（传统C风格）
constexpr int DAYS_IN_WEEK = 7;
constexpr int BUFFER_SIZE = 1024;
```

#### 3.2.4 函数
```cpp
// 常规函数：小写下划线命名法
add_table_entry()
delete_url()
open_file_or_die()

// 取值和设值函数
class my_class {
 public:
  int num_entries() const { return num_entries_; }
  void num_entries(int num) { num_entries_ = num; }
  
 private:
  int num_entries_;
};
```

#### 3.2.5 命名空间
```cpp
// 全小写
namespace myproject {
namespace database {

class database { ... };

}  // namespace database
}  // namespace myproject
```

#### 3.2.6 枚举值
```cpp
// 标准库风格：小写下划线
enum class url_table_error {
  ok = 0,
  out_of_memory,
  malformed_input,
};
```

## 4. 格式规范

### 4.1 缩进
```cpp
// 使用 2 个或 4 个空格缩进
if (condition) {  // 左大括号不换行
  do_something();  // 2 个空格
} else {
  do_something_else();
}
```

### 4.2 行长度
```cpp
// 每行最多 80-120 个字符
// 长表达式可以换行
if (this_one_thing > this_other_thing &&
    a_third_thing == a_fourth_thing &&
    yet_another && last_one) {
  // ...
}
```

### 4.3 函数声明和定义
```cpp
// 返回类型可与函数名在同一行
return_type class_name::function_name(type par_name1, type par_name2) {
  do_something();
  // ...
}
```

## 5. 注释

### 5.1 文件注释
```cpp
// Copyright 2024 Your Company. All rights reserved.
//
// 文件描述
// 简要说明本文件的功能和内容
//
```

### 5.2 类注释
```cpp
// 迭代器，用于遍历 foos 容器中的元素。迭代器是前向迭代器。
class foo_iterator {
  // ...
};
```

### 5.3 函数注释
```cpp
// 计算表格的边界。返回值是边界像素的数量，如果计算失败则返回 -1。
int calculate_table_border();
```

### 5.4 变量注释
```cpp
// 当前活动用户的 ID，如果没有活动用户则为 -1。
int active_user_id;
```

## 6. 包含保护

### 6.1 头文件保护
```cpp
#ifndef FOO_BAR_BAZ_HPP
#define FOO_BAR_BAZ_HPP

// ...

#endif // FOO_BAR_BAZ_HPP
```

## 7. 包含顺序

```cpp
// 1. 关联的头文件
#include "foo/server/fooserver.hpp"

// 2. C 系统头文件
#include <sys/types.h>
#include <unistd.h>

// 3. C++ 标准库头文件
#include <vector>
#include <string>

// 4. 其他库头文件
#include <glog/logging.h>
#include <gflags/gflags.h>

// 5. 本项目头文件
#include "base/basictypes.hpp"
#include "base/commandlineflags.hpp"
```

## 8. 作用域

### 8.1 命名空间
```cpp
// 在 .cc 文件中使用未命名的命名空间
namespace {
// 内容
} // namespace
```

### 8.2 局部变量
```cpp
// 尽可能缩小作用域
int i = f();  // 好 - 声明时初始化

int j = g();  // 好 - 声明时初始化
```

## 9. 类

### 9.1 访问控制顺序
```cpp
class my_class {
 public:      // 公有接口
  my_class();
  ~my_class();
  
  void public_method();
  
 protected:   // 保护接口
  void protected_method();
  
 private:     // 私有实现
  void private_method();
  int private_data;
};
```

## 10. 现代 C++ 特性

### 10.1 智能指针
```cpp
std::unique_ptr<foo> foo_ptr = std::make_unique<foo>();
std::shared_ptr<foo> shared_foo = std::make_shared<foo>();
```

### 10.2 auto
```cpp
// 当类型明显或不重要时使用
auto it = my_map.find(key);
auto* ptr = new foo();
const auto& ref = some_value;
```

### 10.3 范围 for
```cpp
for (const auto& item : container) {
  process(item);
}
```

## 11. 完整示例

```cpp
// 文件: my_project/url_table.hpp
#ifndef MY_PROJECT_URL_TABLE_HPP
#define MY_PROJECT_URL_TABLE_HPP

#include <string>
#include <vector>
#include <memory>

namespace myproject {

// 表示 URL 表中的一行
class url_table_row {
 public:
  explicit url_table_row(const std::string& url);
  ~url_table_row();
  
  const std::string& url() const { return url_; }
  int visit_count() const { return visit_count_; }
  void increment_visit_count() { ++visit_count_; }
  
 private:
  std::string url_;
  int visit_count_ = 0;
};

// 管理 URL 表
class url_table {
 public:
  url_table();
  ~url_table();
  
  // 添加新 URL
  bool add_url(const std::string& url);
  
  // 获取所有 URL
  const std::vector<std::unique_ptr<url_table_row>>& urls() const {
    return urls_;
  }
  
  // 查找 URL
  url_table_row* find_url(const std::string& url);
  
  // 表是否为空
  bool empty() const { return urls_.empty(); }
  int size() const { return static_cast<int>(urls_.size()); }
  
 private:
  std::vector<std::unique_ptr<url_table_row>> urls_;
  
  // 禁用拷贝
  url_table(const url_table&) = delete;
  url_table& operator=(const url_table&) = delete;
};

} // namespace myproject

#endif // MY_PROJECT_URL_TABLE_HPP
```

```cpp
// 文件: my_project/url_table.cpp
#include "my_project/url_table.hpp"

#include <algorithm>

namespace myproject {

url_table_row::url_table_row(const std::string& url) : url_(url) {}

url_table_row::~url_table_row() = default;

url_table::url_table() = default;

url_table::~url_table() = default;

bool url_table::add_url(const std::string& url) {
  if (url.empty()) {
    return false;
  }
  
  // 检查是否已存在
  if (find_url(url) != nullptr) {
    return false;
  }
  
  urls_.push_back(std::make_unique<url_table_row>(url));
  return true;
}

url_table_row* url_table::find_url(const std::string& url) {
  auto it = std::find_if(urls_.begin(), urls_.end(),
                         const std::unique_ptr<url_table_row>& row {
                           return row->url() == url;
                         });
  return (it != urls_.end()) ? it->get() : nullptr;
}

} // namespace myproject
```

## 12. 工具配置

### 12.1 .clang-format
```yaml
BasedOnStyle: LLVM
ColumnLimit: 100
IndentWidth: 2
AccessModifierOffset: -2
NamespaceIndentation: All
AllowShortFunctionsOnASingleLine: Inline
BreakBeforeBraces: Attach
UseTab: Never
```

### 12.2 使用工具
- clang-format: 自动格式化代码
- clang-tidy: 静态分析
- cpplint: 代码风格检查

---

**主要更改说明：**
1. 统一使用 C++ 标准库风格的小写下划线命名法
2. 类、结构体、枚举、函数名全部使用小写下划线
3. 类成员变量无特殊前缀/后缀（可选使用下划线后缀避免命名冲突）
4. 常量不要求特殊前缀，可使用全大写或小写下划线
5. 枚举值使用小写下划线
6. 文件保护格式可使用 `.hpp` 或 `_HPP`
7. 函数返回类型可与函数名同行
8. 使用标准库的命名约定（如 `empty()`, `size()`, `begin()`, `end()`）

**与标准库的一致性：**
- `vector`, `string`, `unordered_map` 等标准库类型
- `make_unique`, `make_shared` 等函数
- `begin()`, `end()`, `size()`, `empty()` 等方法
- 使用小写下划线，保持与标准库一致的代码风格